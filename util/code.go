package util

import (
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"
	"time"
)

//***************************************************
//@Link  https://github.com/thkhxm/tgf
//@Link  https://gitee.com/timgame/tgf
//@QQ群 7400585
//author tim.huang<thkhxm@gmail.com>
//@Description
//2023/4/27
//***************************************************

var autoGenerateAPICodePath = ""

func SetAutoGenerateAPICodePath(path string) {
	var err error
	autoGenerateAPICodePath, err = filepath.Abs(path)
	if err != nil {
		panic(err)
	}
	fmt.Printf("设置api代码自动生成路径为 %v", autoGenerateAPICodePath)
}

// GeneratorAPI
// @Description: 生成api文件
// @param ref
func GeneratorAPI[T any](moduleName, version, packageName string) {
	var t T
	v := reflect.ValueOf(&t)
	ty := v.Type().Elem()
	s := make([]struct {
		Args       string
		Reply      string
		MethodName string
	}, 0)
	a := struct {
		PackageImports []string
		Apis           []struct {
			Args       string
			Reply      string
			MethodName string
		}
	}{}
	tt := make(map[string]bool)
	for i := 0; i < ty.NumMethod(); i++ {
		m := ty.Method(i)
		// 遍历方法的参数列表
		for j := 0; j < m.Type.NumIn(); j++ {
			// 获取参数类型对象
			argType := m.Type.In(j)
			pkg := argType.PkgPath()
			if argType.Kind() == reflect.Pointer {
				pkg = argType.Elem().PkgPath()
				tt[pkg] = true
			}
		}
		s = append(s, struct {
			Args       string
			Reply      string
			MethodName string
		}{Args: m.Type.In(1).String(), Reply: m.Type.In(2).String(), MethodName: m.Name})
	}
	pi := make([]string, 0)
	for k, _ := range tt {
		pi = append(pi, k)
	}
	a.Apis = s
	a.PackageImports = pi

	tpl := fmt.Sprintf(`
//Auto generated by tgf util
//created at %v

package %v

import (
"github.com/thkhxm/tgf/rpc"
{{range .PackageImports}}
"{{.}}"
{{end}}
)
var %vService = &rpc.Module{Name: "%v", Version: "%v"}

var (
	{{range .Apis}}
	{{.MethodName}} = rpc.ServiceAPI[{{.Args}}, {{.Reply}}]{
		ModuleName: %vService.Name,
		Name:       "{{.MethodName}}",
	}
	{{end}}
)

`, time.Now().String(), packageName, moduleName, moduleName, version, moduleName)
	tm := template.New("apiStruct")
	tp, _ := tm.Parse(tpl)
	fileName := strings.ToLower(moduleName) + "_api.go"
	file, err := os.Create(autoGenerateAPICodePath + string(filepath.Separator) + fileName)
	if err != nil {
		panic(err)
	}
	defer file.Close()
	tp.Execute(file, a)
	//tp.Execute(os.Stdout, a)
}

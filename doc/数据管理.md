# 数据管理

框架中分一下几种数据操作

1. 直接操作第三方缓存(redis)
2. 通过数据管理工具操作数据(IAutoCacheService)



### 直接操作第三方缓存

#### Set

```go
//数据12小时后移除
loginTokenTimeOut := time.Hour * 12
uuid := 1
key = fmt.Sprintf("example:key:%v", uuid)
db.Set(key, "123", loginTokenTimeOut)
```



#### Get

```go
uuid := 1
key = fmt.Sprintf("example:key:%v", uuid)
curToken, _ := db.Get[string](key)
//print:
//curToken = "123"
```



#### Del

```go
key = fmt.Sprintf("example:key:%v", uuid)
db.Del(key)
// 数据在超过一定时间后会自动删除
```



#### DelNow

```go
key = fmt.Sprintf("example:key:%v", uuid)
db.DelNow(key)
// 数据立马删除
```

 **当然还有很多其他常规的操作接口, 这里就不一一展示了. 都是通用操作存放在db包下**

### 数据管理工具

​	**以下是快速入门的常用案例**

#### NewDefaultAutoCacheManager

```go
cacheManager := db.NewDefaultAutoCacheManager[string, int64]("example")
	key := "1001"
	var setVal int64 = 10086
	val, err := cacheManager.Get(key)
	if err != nil {
		t.Errorf("[test] cache get error %v", err)
		return
	}
	//
	t.Logf("[test] cache first get key %v , val %v", key, val)

	cacheManager.Set(key, setVal)
	t.Logf("[test] cache set key %v , val %v ", key, setVal)
	val, err = cacheManager.Get(key)
	if err != nil {
		t.Errorf("[test] cache get error %v", err)
		return
	}
	t.Logf("[test] cache second get key %v , val %v", key, val)

	//first run
	//[test] cache first get key 1001 , val 0
	//[test] cache set key 1001 , val 0
	//[test] cache second get key 1001 , val 10086

	//second run
	//[test] cache first get key 1001 , val 10086
	//[test] cache set key 1001 , val 10086
	//[test] cache second get key 1001 , val 10086
```

​	在以上案例中，我们初始化了一个key为string，val为int64的数据管理类，使用“example”作为常用的key。

   如果我们val是一个结构类型的数据，那么底层代码会帮我们自动转成json的数据存放到redis中，不需要我们关注存放的结构问题.

​	默认不包含持久化数据落地(mysql)，包含本地缓存，cache缓存(redis)

​	cache缓存使用example作为组合key，例如key如果为1001，那么cache中的key为example:1001  拼装方式为cacheKey:key

​	默认cache缓存超时时间为3天，本地缓存清除时间为3小时.

​	db包中还提供另外两个快速创建的方法,分别是

#### NewLongevityAutoCacheManager

```go
type User struct{
    Uid int64 "'orm:`pk`'"
    Name string 
}

//需要实现 db.IModel接口
func (this User) GetTableName() string{...}

//Val泛型参数，需要实现IModel接口
cacheManager := db.NewLongevityAutoCacheManager[string, User]("example")

```

​	上述代码中,get set等操作与平时一样，底层会自动定时将数据缓存到redis和mysql，进行更新或者增量.

​	其中redis为实时同步更新，mysql为异步批量更新，实现多次操作，缓存一步更新，数据库定时一步更新，减少了数据库的频繁读写.

​	开发者不用关注数据的持久化，也不需要接触任何sql，默认在本地进行mysql的数据更新.

#### NewAutoCacheManager

```go
cacheManager := db.NewAutoCacheManager[string, string]()
key := "123"
val := "321"
cacheManager.Set(key, val)
data, _ := cacheManager.Get(key)
```

​	上述代码中,get set等操作与平时一样,使用了简单的本地缓存管理数据 ,  不包括redis和mysql的操作.数据的生命周期与节点一致.



**如果需要自定义相关参数，推荐使用自定义数据管理的方式创建**

#### 自定义数据管理工具

```go
cacheManager := db.NewDefaultAutoCacheManager[string, int64]("example")
	key := "1001"
	var setVal int64 = 10086
	val, err := cacheManager.Get(key)
	if err != nil {
		t.Errorf("[test] cache get error %v", err)
		return
	}
	//
	t.Logf("[test] cache first get key %v , val %v", key, val)

	cacheManager.Set(key, setVal)
	t.Logf("[test] cache set key %v , val %v ", key, setVal)
	val, err = cacheManager.Get(key)
	if err != nil {
		t.Errorf("[test] cache get error %v", err)
		return
	}
	t.Logf("[test] cache second get key %v , val %v", key, val)

	//first run
	//[test] cache first get key 1001 , val 0
	//[test] cache set key 1001 , val 0
	//[test] cache second get key 1001 , val 10086

	//second run
	//[test] cache first get key 1001 , val 10086
	//[test] cache set key 1001 , val 10086
	//[test] cache second get key 1001 , val 10086
```

​	

### 游戏配置管理

执行下列代码，自动生成对应的json和golang文件，不设置路径，不生成

```go
func main() {	
	util.SetExcelPath("./cmd/excel")
	util.SetExcelToJsonPath("./cmd/json")
	util.SetExcelToGoPath("./conf")
	util.ExcelExport()
}
```

